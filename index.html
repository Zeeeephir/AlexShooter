<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AlexShooter</title>
    <!-- Three.js pour la 3D -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Police Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <!-- Font Awesome pour les icônes -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        /* Styles réinitialisés */
        body, html {
            margin: 0; padding: 0; overflow: hidden; font-family: 'Inter', sans-serif;
            background-color: #1a202c; color: #e2e8f0;
        }
        canvas { display: block; width: 100vw; height: 100vh; }
        #game-container {
            position: relative; width: 100vw; height: 100vh; display: flex;
            justify-content: center; align-items: center; flex-direction: column;
            background-color: #2d3748; display: none;
        }
        #main-menu {
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
            background: linear-gradient(135deg, rgba(26,32,44,0.9) 0%, rgba(45,55,72,0.9) 100%), url('https://upload.wikimedia.org/wikipedia/commons/thumb/1/11/Apocalyptic_Cityscape_1.png/1920px-Apocalyptic_Cityscape_1.png') no-repeat center center / cover;
            background-blend-mode: overlay; position: relative; overflow: hidden;
            display: flex; flex-direction: column; justify-content: center;
            align-items: center; z-index: 103; text-align: center;
        }
        #main-menu h1 {
            font-size: 5rem; font-weight: 800; margin-bottom: 60px; color: #ffffff;
            text-shadow: 0 5px 15px rgba(0, 0, 0, 0.5), 0 0 20px rgba(66, 153, 225, 0.7);
            letter-spacing: 5px; transition: all 0.3s ease-in-out; position: relative; z-index: 2;
        }
        #main-menu h1:hover {
            transform: scale(1.02); color: #4299e1;
            text-shadow: 0 5px 20px rgba(66, 153, 225, 0.9), 0 0 30px rgba(66, 153, 225, 0.9);
        }
        .menu-buttons-wrapper {
            display: flex; flex-direction: column; gap: 25px; z-index: 2;
        }
        .menu-button {
            background: linear-gradient(145deg, #2a3d5e 0%, #1a202c 100%); color: white;
            padding: 15px 35px; border-radius: 12px; border: 1px solid rgba(66, 153, 225, 0.5);
            cursor: pointer; font-size: 1.6rem; font-weight: bold; transition: all 0.3s ease-in-out;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.5), inset 0 2px 4px rgba(255, 255, 255, 0.1);
            width: 280px; letter-spacing: 1px; position: relative; overflow: hidden; z-index: 2;
        }
        .menu-button::before {
            content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.1); transition: all 0.4s ease-in-out;
            transform: skewX(-20deg);
        }
        .menu-button:hover::before { left: 100%; }
        .menu-button:hover {
            background: linear-gradient(145deg, #3182ce 0%, #2a3d5e 100%);
            transform: translateY(-4px) scale(1.01);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.7), inset 0 2px 6px rgba(255, 255, 255, 0.2);
            border-color: #4299e1;
        }
        .menu-button:active {
            transform: translateY(0) scale(1);
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.4), inset 0 1px 3px rgba(255, 255, 255, 0.1);
            background: linear-gradient(145deg, #1a202c 0%, #2a3d5e 100%);
        }

        /* Effets de tir pour le fond du menu */
        @keyframes shooting-effect {
            0% { opacity: 0; transform: translate(0, 0) scale(0.5); filter: brightness(1); }
            10% { opacity: 1; transform: translate(calc(var(--rand-x) * 1vw), calc(var(--rand-y) * 1vh)) scale(1.5); filter: brightness(2); }
            20% { opacity: 0; transform: translate(calc(var(--rand-x) * 2vw), calc(var(--rand-y) * 2vh)) scale(0.8); filter: brightness(1); }
            100% { opacity: 0; }
        }
        .shooting-flash {
            position: absolute; width: 50px; height: 50px;
            background: radial-gradient(circle, rgba(255, 255, 150, 0.8) 0%, rgba(255, 165, 0, 0) 70%);
            border-radius: 50%; pointer-events: none; z-index: 1;
            animation: shooting-effect 3s infinite ease-out;
            --rand-x: 0; --rand-y: 0; --rand-delay: 0s; animation-delay: var(--rand-delay);
        }

        /* Éléments d'interface utilisateur en jeu */
        #info-box {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7); padding: 15px 25px; border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3); text-align: center; font-size: 1.1rem;
            max-width: 90%; z-index: 100; display: none;
        }
        #controls-info { font-size: 0.9rem; margin-top: 10px; color: #a0aec0; }
        #message-box {
            position: absolute; top: 100px; left: 50%; transform: translateX(-50%);
            background-color: rgba(255, 255, 0, 0.8); color: #333; padding: 10px 20px;
            border-radius: 8px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); font-weight: bold;
            display: none; z-index: 99; white-space: nowrap;
        }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            margin-left: -10px; margin-top: -10px; border: 1px solid white;
            border-radius: 50%; box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
            pointer-events: none; z-index: 100;
        }
        #crosshair::before, #crosshair::after { content: ''; position: absolute; background-color: white; }
        #crosshair::before { width: 2px; height: 10px; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        #crosshair::after { width: 10px; height: 2px; top: 50%; left: 50%; transform: translate(-50%, -50%); }
        .aiming #crosshair { border-color: red; box-shadow: 0 0 8px rgba(255, 0, 0, 0.7); }
        .aiming #crosshair::before, .aiming #crosshair::after { background-color: red; }

        /* Section des paramètres */
        #settings-section {
            background-color: #2d3748; padding: 30px; border-radius: 15px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5); text-align: center; width: 90%;
            max-width: 500px; min-height: 250px; color: #e2e8f0; display: flex;
            flex-direction: column; justify-content: center; align-items: center;
            display: none; margin-top: 20px; z-index: 2;
        }
        #settings-section h2 { font-size: 2rem; margin-bottom: 20px; color: #4299e1; }
        #settings-section label, #settings-section p {
            display: block; margin: 5px auto; color: #e2e8f0; width: 100%; text-align: center;
        }
        #settings-section input[type="range"] {
            width: 80%; margin: 10px auto; background-color: #555555; -webkit-appearance: none;
            height: 8px; border-radius: 4px; outline: none;
        }
        #settings-section input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 20px; height: 20px; border-radius: 50%;
            background: #4299e1; cursor: pointer; margin-top: -6px; box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        #settings-section .controls-group {
            display: block; margin: 15px auto; color: #e2e8f0;
            background-color: rgba(255, 255, 255, 0.05); padding: 10px;
            border-radius: 8px; width: 80%; max-width: 350px;
        }
        .key-remap-row {
            display: flex; justify-content: space-between; align-items: center;
            width: 100%; margin: 8px auto; padding: 5px 10px;
            background-color: rgba(255, 255, 255, 0.08); border-radius: 5px;
        }
        .key-remap-row span { font-size: 1rem; color: #cbd5e0; }
        .key-remap-button {
            background-color: #63b3ed; color: white; padding: 5px 10px;
            border-radius: 5px; border: none; cursor: pointer; font-size: 0.9rem;
            min-width: 60px; text-align: center; transition: background-color 0.15s;
        }
        .key-remap-button:hover { background-color: #4299e1; }
        .key-remap-button.active { background-color: #f6ad55; }

        /* Menu de pause */
        #pause-menu {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background-color: rgba(0, 0, 0, 0.85); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 999; display: none;
        }
        #pause-menu h2 {
            font-size: 3rem; font-weight: bold; margin-bottom: 40px; color: #4299e1;
            text-shadow: 0 0 10px rgba(66, 153, 225, 0.7);
        }
        #pause-menu .menu-button { margin: 10px 0; }

        /* Modale de confirmation de quitter */
        #quit-confirm-modal {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background-color: rgba(0, 0, 0, 0.9); display: flex; justify-content: center;
            align-items: center; z-index: 1000; display: none;
        }
        #quit-confirm-content {
            background-color: #2d3748; padding: 30px; border-radius: 15px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.5); text-align: center; width: 90%;
            max-width: 400px; color: #e2e8f0;
        }
        #quit-confirm-content p { font-size: 1.2rem; margin-bottom: 25px; }
        #quit-confirm-content .button-group { display: flex; justify-content: center; gap: 20px; }
        #quit-confirm-content .button-group button {
            background-color: #e53e3e; color: white; padding: 10px 20px;
            border-radius: 8px; border: none; cursor: pointer; font-size: 1rem;
            transition: background-color 0.2s;
        }
        #quit-confirm-content .button-group button:hover { background-color: #c53030; }
        #quit-confirm-content .button-group button#confirm-quit-no { background-color: #48bb78; }
        #quit-confirm-content .button-group button#confirm-quit-no:hover { background-color: #38a169; }

        /* HUD pour les munitions, la vie, les infos de manche */
        #ammo-display {
            position: absolute; bottom: 20px; right: 20px; background-color: rgba(0, 0, 0, 0.7);
            color: #e2e8f0; padding: 10px 15px; border-radius: 8px; font-size: 1.5rem;
            font-weight: bold; z-index: 90; display: none;
        }
        #ammo-display.reloading { color: #f6ad55; }
        #health-display {
            position: absolute; bottom: 20px; left: 20px; width: 200px; height: 30px;
            background-color: rgba(0, 0, 0, 0.7); border-radius: 8px; overflow: hidden;
            z-index: 90; display: none;
        }
        #health-bar {
            height: 100%; background-color: #e53e3e; transition: width 0.2s ease-out;
            display: flex; align-items: center; justify-content: center; color: white;
            font-weight: bold; font-size: 1.2rem;
        }
        #wave-info {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7); color: #e2e8f0; padding: 10px 15px;
            border-radius: 8px; font-size: 1.2rem; font-weight: bold; text-align: center;
            z-index: 90; display: none;
        }
        #wave-info p { margin: 0; padding: 0; }

        /* Écran de fin de partie */
        #game-over-screen {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background-color: rgba(0, 0, 0, 0.95); display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 1001;
            display: none; color: white; text-align: center;
        }
        #game-over-screen h2 {
            font-size: 4rem; color: #e53e3e; text-shadow: 0 0 15px rgba(229, 62, 62, 0.7);
            margin-bottom: 30px;
        }
        #game-over-screen p { font-size: 1.8rem; margin-bottom: 15px; }
        #game-over-screen .menu-button { margin-top: 30px; }
    </style>
</head>
<body class="bg-gray-900 text-gray-200">
    <div id="game-container" class="relative w-screen h-screen overflow-hidden">
        <div id="info-box" class="rounded-xl">
            <h1 class="text-2xl font-bold mb-2">Bienvenue dans AlexShooter !</h1>
            <p>Cliquez n'importe où pour commencer le jeu et bloquer votre souris.</p>
            <p id="controls-info">Contrôles par défaut (AZERTY) : Z pour Avancer, Q pour Strafe Gauche, S pour Reculer, D pour Strafe Droite. Clic gauche pour Tirer, Clic droit pour Viser. Espace pour sauter, C pour coup de couteau, R pour recharger.</p>
        </div>
        <div id="message-box"></div>
        <div id="crosshair"></div>
        <div id="ammo-display">30 / 90</div>
        <div id="health-display"><div id="health-bar">100 HP</div></div>
        <div id="wave-info"><p>Manche: <span id="current-wave-display">1</span></p><p>Alex Restants: <span id="alexes-remaining-display">0</span></p></div>
    </div>
    <div id="main-menu">
        <h1 id="main-menu-title">AlexShooter</h1>
        <div id="menu-buttons-container" class="menu-buttons-wrapper">
            <button id="start-game-button" class="menu-button">Démarrer le jeu</button>
            <button id="main-menu-settings-button" class="menu-button">Paramètres</button>
        </div>
        <div id="settings-section">
            <h2>Paramètres du Jeu</h2>
            <label for="sensitivity-slider">Sensibilité de la souris:</label>
            <input type="range" id="sensitivity-slider" min="0.0005" max="0.005" step="0.0001" value="0.002">
            <p>Sensibilité actuelle: <span id="current-sensitivity">0.002</span></p>
            <div class="controls-group">
                <label>Changer les touches de déplacement :</label>
                <div class="key-remap-row"><span>Avancer:</span> <button id="remap-moveForward" class="key-remap-button">Z</button></div>
                <div class="key-remap-row"><span>Reculer:</span> <button id="remap-moveBackward" class="key-remap-button">S</button></div>
                <div class="key-remap-row"><span>Strafe Gauche:</span> <button id="remap-strafeLeft" class="key-remap-button">Q</button></div>
                <div class="key-remap-row"><span>Strafe Droite:</span> <button id="remap-strafeRight" class="key-remap-button">D</button></div>
                <div class="key-remap-row"><span>Sauter:</span> <button id="remap-jump" class="key-remap-button">Espace</button></div>
                <div class="key-remap-row"><span>Coup de Couteau:</span> <button id="remap-knife" class="key-remap-button">C</button></div>
                <div class="key-remap-row"><span>Recharger:</span> <button id="remap-reload" class="key-remap-button">R</button></div>
            </div>
            <div class="controls-group">
                <p>Tirer: Clic Gauche</p>
                <p>Viser: Clic Droit</p>
                <p>Retour au menu principal/Paramètres: Échap</p>
            </div>
            <button id="reset-keys-button" class="menu-button">Réinitialiser les touches</button>
            <button id="back-to-main-menu-button" class="menu-button">Retour au Menu Principal</button>
        </div>
    </div>
    <div id="pause-menu">
        <h2>PAUSE</h2>
        <button id="resume-button" class="menu-button">Reprendre</button>
        <button id="pause-settings-button" class="menu-button">Paramètres</button>
        <button id="quit-to-main-button" class="menu-button">Retour au Menu Principal</button>
    </div>
    <div id="quit-confirm-modal">
        <div id="quit-confirm-content">
            <p>Êtes-vous sûr de vouloir quitter ? Toute progression non sauvegardée sera perdue.</p>
            <div class="button-group">
                <button id="confirm-quit-yes">Oui</button>
                <button id="confirm-quit-no">Non</button>
            </div>
        </div>
    </div>
    <div id="game-over-screen">
        <h2>GAME OVER</h2>
        <p>Alexes tués : <span id="final-alex-kills">0</span></p>
        <p>Manches survécues : <span id="final-waves-survived">0</span></p>
        <button id="replay-button" class="menu-button">Rejouer</button>
    </div>

    <script>
        // --- Variables Globales Three.js ---
        let scene, camera, renderer, playerContainer, playerVelocity, rotationSpeed = 0.002, keyboard = {};
        let isAiming = false, alexes = [], collidableObjects = [], raycaster = new THREE.Raycaster();
        let messageBox, crosshair, weaponMesh, armMesh, ground, spawnAreaRadius, debugRayLine;

        // Références des éléments de l'interface utilisateur
        let mainMenuDiv, gameContainer, infoBox, settingsSection;
        let startGameButton, mainMenuSettingsButton, backToMainMenuButton, resetKeysButton;
        let sensitivitySlider, currentSensitivityDisplay;
        let pauseMenu, resumeButton, pauseSettingsButton, quitToMainButton;
        let quitConfirmModal, confirmQuitYesButton, confirmQuitNoButton;
        let ammoDisplay, healthDisplay, healthBar;
        let waveInfo, currentWaveDisplay, alexesRemainingDisplay;
        let gameOverScreen, finalAlexKillsDisplay, finalWavesSurvivedDisplay, replayButton;

        // État du jeu
        let gameActive = false, playerVerticalVelocity = 0, canJump = true;
        const moveSpeed = 5.0; // Vitesse de déplacement du joueur (ajustée pour deltaTime)
        const gravity = -9.8; // Force de gravité (m/s^2)
        const jumpStrength = 5.0; // Force de saut (impulsion initiale)
        const playerCollisionRadius = 0.5; // Rayon de collision du joueur
        const playerHeight = 1.7; // Hauteur du joueur (pour le calcul des pieds)
        const playerStepHeight = 0.5; // Hauteur maximale que le joueur peut monter automatiquement
        let playerHealth = 100, maxPlayerHealth = 100, playerDamageCooldown = 0;
        const playerDamageCooldownDuration = 200; // Durée d'invincibilité après dégâts
        let currentAmmo = 30, magazineCapacity = 30, totalReserveAmmo = 90, isReloading = false;
        const reloadDuration = 2000; // Durée du rechargement
        let knifeCooldown = 1000, isKnifeReady = true;
        const knifeRange = 2.5, knifeDamage = 20, knifeAttackDuration = 200;
        let knifeVisual; // Objet 3D du couteau
        const SHOOT_RANGE = 100; // Portée de tir

        // Gestion des vagues
        let currentWave = 0, alexesKilledThisWave = 0, totalAlexesKilledOverall = 0;
        let alexesInCurrentWave = [], waveSpawnTimer = null;
        const timeBetweenWaves = 3000; // Temps entre les vagues

        // Propriétés d'Alex (ennemi)
        const ALEX_BASE_SPEED = 2.0; // Vitesse de base des Alex (ajustée pour deltaTime)
        const ALEX_BASE_HEALTH = 100;
        const ALEX_BASE_DAMAGE = 10;
        const ALEX_ATTACK_COOLDOWN = 1500;
        const ALEX_COLLISION_RADIUS = 0.5;
        const ALEX_ATTACK_RANGE_THRESHOLD = playerCollisionRadius + ALEX_COLLISION_RADIUS + 0.5;

        // État de l'interface utilisateur
        let currentUIMode = 'mainMenu', previousUIMode = 'mainMenu', isPointerLockRequested = false;

        // Liaisons des touches (codes basés sur QWERTY pour la robustesse)
        let keyBindings = {
            'moveForward': 'KeyW', 'moveBackward': 'KeyS', 'strafeLeft': 'KeyA',
            'strafeRight': 'KeyD', 'jump': 'Space', 'knife': 'KeyC', 'reload': 'KeyR'
        };
        const defaultKeyBindings = { ...keyBindings }; // Copie pour la réinitialisation

        let isRemappingKey = false, currentRemapButton = null, currentRemapAction = null;
        const NUM_SHOOTING_EFFECTS = 5;
        let shootingEffectElements = [];
        let lastFrameTime = performance.now(); // Pour le calcul du deltaTime

        // Global variables for map dimensions (moved from generatePowerPlant scope)
        let mainHallX, mainHallZ, mainHallWidth, mainHallDepth, mainHallHeight, wallThickness;
        let boilerHallX, boilerHallZ, boilerWidth, boilerDepth;


        // --- Fonctions d'aide globales ---

        /**
         * Gère les événements keydown pour les commandes de jeu et la navigation dans les menus.
         * @param {KeyboardEvent} event L'événement clavier.
         */
        function handleGameKeydown(event) {
            keyboard[event.code] = true;
            if (event.code === 'Escape') {
                if (isRemappingKey) { endRemap(currentRemapAction, null); }
                else if (currentUIMode === 'quitConfirm') { hideQuitConfirm(); showPauseMenu(); }
                else if (currentUIMode === 'game') { showPauseMenu(); document.exitPointerLock(); }
                else if (currentUIMode === 'pauseMenu') { hidePauseMenu(); requestGamePointerLock(true); }
                else if (currentUIMode === 'settings') {
                    if (previousUIMode === 'pauseMenu') { showPauseMenu(); }
                    else { showMenuScreen(); }
                }
                event.preventDefault();
            }
            if (gameActive) {
                if (event.code === keyBindings.jump && canJump) { performJump(); }
                if (event.code === keyBindings.knife && isKnifeReady && !isReloading) { performKnifeAttack(); }
                if (event.code === keyBindings.reload && !isReloading && currentAmmo < magazineCapacity) { performReload(); }
            }
        }

        /**
         * Gère les événements keyup.
         * @param {KeyboardEvent} event L'événement clavier.
         */
        function handleGameKeyup(event) { keyboard[event.code] = false; }

        /**
         * Formate les codes de touche pour l'affichage (par exemple, 'KeyW' en 'Z' pour AZERTY).
         * @param {string} code Le code de l'événement clavier.
         * @returns {string} Chaîne formatée pour l'affichage.
         */
        function formatKeyCode(code) {
            if (!code) return "";
            switch (code) {
                case 'KeyW': return 'Z'; case 'KeyA': return 'Q'; case 'KeyS': return 'S';
                case 'KeyD': return 'D'; case 'Space': return 'Espace'; case 'KeyC': return 'C';
                case 'KeyR': return 'R'; case 'ControlLeft': return 'Ctrl Gauche';
                case 'ControlRight': return 'Ctrl Droit'; case 'AltLeft': return 'Alt Gauche';
                case 'AltRight': return 'Alt Droit'; case 'ShiftLeft': return 'Maj Gauche';
                case 'ShiftRight': return 'Maj Droit'; case 'Enter': return 'Entrée';
                case 'Backspace': return 'Retour Arrière'; case 'Tab': return 'Tab';
                case 'CapsLock': return 'Verrou Maj'; case 'ArrowUp': return 'Flèche Haut';
                case 'ArrowDown': return 'Flèche Bas'; case 'ArrowLeft': return 'Flèche Gauche';
                case 'ArrowRight': return 'Flèche Droite';
                default: return code.startsWith('Key') ? code.substring(3) : (code.startsWith('Digit') ? code.substring(5) : code);
            }
        }

        /**
         * Formate les noms d'action pour les messages.
         * @param {string} action Le nom interne de l'action.
         * @returns {string} Nom d'action convivial.
         */
        function formatActionName(action) {
            switch(action) {
                case 'moveForward': return 'Avancer'; case 'moveBackward': return 'Reculer';
                case 'strafeLeft': return 'Strafe Gauche'; case 'strafeRight': return 'Strafe Droite';
                case 'jump': return 'Sauter'; case 'knife': return 'Coup de Couteau';
                case 'reload': return 'Recharger'; default: return action;
            }
        }

        /** Met à jour le texte des boutons de remappage des touches. */
        function updateKeyRemapButtons() {
            document.getElementById('remap-moveForward').textContent = formatKeyCode(keyBindings.moveForward);
            document.getElementById('remap-moveBackward').textContent = formatKeyCode(keyBindings.moveBackward);
            document.getElementById('remap-strafeLeft').textContent = formatKeyCode(keyBindings.strafeLeft);
            document.getElementById('remap-strafeRight').textContent = formatKeyCode(keyBindings.strafeRight);
            document.getElementById('remap-jump').textContent = formatKeyCode(keyBindings.jump);
            document.getElementById('remap-knife').textContent = formatKeyCode(keyBindings.knife);
            document.getElementById('remap-reload').textContent = formatKeyCode(keyBindings.reload);
        }

        /**
         * Démarre le processus de remappage d'une touche.
         * @param {string} action L'action à remapper.
         * @param {HTMLButtonElement} buttonElement L'élément bouton associé.
         */
        function startRemap(action, buttonElement) {
            if (isRemappingKey) return;
            isRemappingKey = true; currentRemapAction = action; currentRemapButton = buttonElement;
            currentRemapButton.textContent = "Appuyez sur une touche...";
            currentRemapButton.classList.add('active');
            document.removeEventListener('keydown', handleGameKeydown);
            document.removeEventListener('keyup', handleGameKeyup);
            document.addEventListener('keydown', handleRemapKeydown, { once: true });
        }

        /**
         * Gestionnaire pour l'événement keydown de remappage.
         * @param {KeyboardEvent} event L'événement clavier.
         */
        function handleRemapKeydown(event) {
            event.preventDefault();
            if (event.code === 'Escape') { endRemap(currentRemapAction, null); return; }
            const newKey = event.code;
            endRemap(currentRemapAction, newKey);
        }

        /**
         * Termine le processus de remappage d'une touche.
         * @param {string} action L'action qui était remappée.
         * @param {string|null} newKey Le nouveau code de touche, ou null si annulé.
         */
        function endRemap(action, newKey) {
            if (newKey) {
                keyBindings[action] = newKey;
                showMessage(`${formatActionName(action)} remappé à ${formatKeyCode(newKey)}`, 2000);
            } else {
                showMessage(`Remappage de ${formatActionName(action)} annulé.`, 2000);
            }
            if (currentRemapButton) {
                currentRemapButton.textContent = formatKeyCode(keyBindings[action]);
                currentRemapButton.classList.remove('active');
            }
            isRemappingKey = false; currentRemapAction = null; currentRemapButton = null;
            document.addEventListener('keydown', handleGameKeydown);
            document.addEventListener('keyup', handleGameKeyup);
        }

        /** Réinitialise les touches à leurs valeurs par défaut. */
        function resetKeysToDefault() {
            Object.assign(keyBindings, defaultKeyBindings);
            updateKeyRemapButtons();
            showMessage("Touches réinitialisées aux valeurs par défaut.", 2000);
        }

        /** Gère les événements de redimensionnement de la fenêtre. */
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /**
         * Gère le mouvement de la souris, en faisant pivoter la caméra.
         * @param {MouseEvent} event L'événement souris.
         */
        function onMouseMove(event) {
            if (gameActive) {
                const deltaX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                const deltaY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
                playerContainer.rotation.y -= deltaX * rotationSpeed;
                let newPitch = camera.rotation.x - deltaY * rotationSpeed;
                newPitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, newPitch));
                camera.rotation.x = newPitch;
                if (armMesh) {
                    // Adjust arm/weapon position based on camera pitch for a more natural feel
                    armMesh.position.z = -1.0 + Math.sin(newPitch * 0.5) * 0.2;
                    armMesh.position.y = -0.7 - Math.abs(Math.sin(newPitch * 0.5)) * 0.1;
                    armMesh.rotation.x = -Math.PI / 6 + (newPitch * 0.2);
                }
            }
        }

        /**
         * Gère les événements de clic de souris (tir, visée).
         * @param {MouseEvent} event L'événement souris.
         */
        function onMouseDown(event) {
            if (!gameActive) return;
            if (event.button === 0) { shoot(); }
            else if (event.button === 2) {
                isAiming = true; document.body.classList.add('aiming');
                if (armMesh) { armMesh.position.set(0, -0.4, -0.8); armMesh.rotation.x = -Math.PI / 10; }
            }
        }

        /**
         * Gère le relâchement du clic de souris.
         * @param {MouseEvent} event L'événement souris.
         */
        function onMouseUp(event) {
            if (!gameActive) return;
            if (event.button === 2) {
                isAiming = false; document.body.classList.remove('aiming');
                if (armMesh) { armMesh.position.set(0.5, -0.7, -1.0); armMesh.rotation.x = -Math.PI / 6; }
            }
        }

        /**
         * Affiche un message temporaire dans l'interface utilisateur.
         * @param {string} text Le message à afficher.
         * @param {number} duration La durée en millisecondes.
         */
        function showMessage(text, duration = 2000) {
            messageBox.textContent = text; messageBox.style.display = 'block';
            setTimeout(() => { messageBox.style.display = 'none'; }, duration);
        }

        /** Gère l'action de tir du joueur. */
        function shoot() {
            if (!gameActive || isReloading) { return; }
            if (currentAmmo <= 0) { performReload(); return; }
            currentAmmo--; updateAmmoDisplay();
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera); raycaster.far = SHOOT_RANGE;

            // Debug ray line visualization
            if (debugRayLine) {
                const rayDirection = new THREE.Vector3(); camera.getWorldDirection(rayDirection);
                debugRayLine.geometry.attributes.position.array[0] = 0; debugRayLine.geometry.attributes.position.array[1] = 0;
                debugRayLine.geometry.attributes.position.array[2] = 0;
                debugRayLine.geometry.attributes.position.array[3] = rayDirection.x * SHOOT_RANGE;
                debugRayLine.geometry.attributes.position.array[4] = rayDirection.y * SHOOT_RANGE;
                debugRayLine.geometry.attributes.position.array[5] = rayDirection.z * SHOOT_RANGE;
                debugRayLine.geometry.attributes.position.needsUpdate = true;
                debugRayLine.visible = true; setTimeout(() => { debugRayLine.visible = false; }, 100);
            }

            const alexMeshes = alexes.map(a => a.mesh);
            const intersects = raycaster.intersectObjects(alexMeshes, true);
            if (intersects.length > 0) {
                const hitAlexIntersection = intersects.find(intersect => {
                    let obj = intersect.object;
                    while (obj) { if (obj.userData && obj.userData.alexInstance) { return true; } obj = obj.parent; }
                    return false;
                });
                if (hitAlexIntersection) {
                    let hitObject = hitAlexIntersection.object; let hitAlex = null;
                    while (hitObject && !hitAlex) {
                        if (hitObject.userData && hitObject.userData.alexInstance) { hitAlex = hitObject.userData.alexInstance; }
                        hitObject = hitObject.parent;
                    }
                    if (hitAlex) { hitAlex.takeDamage(10); } // Apply damage to Alex
                }
            }
        }

        /** Gère l'action de saut du joueur. */
        function performJump() {
            if (canJump) {
                playerVerticalVelocity = jumpStrength; // Apply immediate upward velocity
                canJump = false;
            }
        }

        /** Gère l'attaque au couteau du joueur. */
        function performKnifeAttack() {
            if (!isKnifeReady) return;
            isKnifeReady = false;

            // Create knife visual if it doesn't exist or was removed
            if (!knifeVisual) {
                const bladeGeometry = new THREE.BoxGeometry(0.05, 0.5, 0.05);
                const handleGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.2, 8);
                const knifeMaterial = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8, roughness: 0.2 });
                knifeVisual = new THREE.Group();
                const blade = new THREE.Mesh(bladeGeometry, knifeMaterial);
                const handle = new THREE.Mesh(handleGeometry, new THREE.MeshStandardMaterial({ color: 0x333333 }));
                blade.position.y = 0.25; handle.position.y = -0.1;
                knifeVisual.add(blade); knifeVisual.add(handle);
                knifeVisual.position.set(0.6, -0.6, -1.0); // Initial position relative to camera
                knifeVisual.rotation.z = Math.PI / 2; // Initial rotation
                camera.add(knifeVisual);
            } else {
                // If it exists but was removed, re-add it
                if (!knifeVisual.parent) camera.add(knifeVisual);
            }


            const initialPos = new THREE.Vector3(0.6, -0.6, -1.0);
            const swingPos = new THREE.Vector3(0.8, -0.4, -1.2);
            const swingRotation = new THREE.Euler(Math.PI / 4, Math.PI / 8, Math.PI / 2);
            let startTime = performance.now();

            function animateKnifeSwing() {
                if (!knifeVisual || !gameActive) { // Ensure knife visual exists and game is active
                    if (knifeVisual && knifeVisual.parent) camera.remove(knifeVisual);
                    return;
                }
                const elapsed = performance.now() - startTime;
                const progress = elapsed / knifeAttackDuration;

                if (progress < 0.5) { // Swing forward
                    knifeVisual.position.lerpVectors(initialPos, swingPos, progress * 2);
                    knifeVisual.rotation.x = THREE.MathUtils.lerp(-Math.PI / 6 + (camera.rotation.x * 0.2), swingRotation.x, progress * 2);
                    knifeVisual.rotation.y = THREE.MathUtils.lerp(Math.PI / 8, swingRotation.y, progress * 2);
                    knifeVisual.rotation.z = THREE.MathUtils.lerp(Math.PI / 2, swingRotation.z, progress * 2);
                } else if (progress < 1.0) { // Swing back
                    knifeVisual.position.lerpVectors(swingPos, initialPos, (progress - 0.5) * 2);
                    knifeVisual.rotation.x = THREE.MathUtils.lerp(swingRotation.x, -Math.PI / 6 + (camera.rotation.x * 0.2), (progress - 0.5) * 2);
                    knifeVisual.rotation.y = THREE.MathUtils.lerp(swingRotation.y, Math.PI / 8, (progress - 0.5) * 2);
                    knifeVisual.rotation.z = THREE.MathUtils.lerp(Math.PI / 2, swingRotation.z, (progress - 0.5) * 2);
                } else { // Animation complete
                    if (knifeVisual.parent) { camera.remove(knifeVisual); } // Remove knife visual after animation
                    return;
                }
                requestAnimationFrame(animateKnifeSwing);
            }
            animateKnifeSwing();

            // Perform raycast for knife damage
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera); raycaster.far = knifeRange;
            if (debugRayLine) { // Debug visualization for knife raycast
                const rayDirection = new THREE.Vector3(); camera.getWorldDirection(rayDirection);
                debugRayLine.geometry.attributes.position.array[0] = 0; debugRayLine.geometry.attributes.position.array[1] = 0;
                debugRayLine.geometry.attributes.position.array[2] = 0;
                debugRayLine.geometry.attributes.position.array[3] = rayDirection.x * knifeRange;
                debugRayLine.geometry.attributes.position.array[4] = rayDirection.y * knifeRange;
                debugRayLine.geometry.attributes.position.array[5] = rayDirection.z * knifeRange;
                debugRayLine.geometry.attributes.position.needsUpdate = true;
                debugRayLine.visible = true; setTimeout(() => { debugRayLine.visible = false; }, 100);
            }
            const alexMeshes = alexes.map(a => a.mesh);
            const intersects = raycaster.intersectObjects(alexMeshes, true);
            if (intersects.length > 0) {
                const hitAlexIntersection = intersects.find(intersect => {
                    let obj = intersect.object;
                    while (obj) { if (obj.userData && obj.userData.alexInstance) { return true; } obj = obj.parent; }
                    return false;
                });
                if (hitAlexIntersection) {
                    let hitObject = hitAlexIntersection.object; let hitAlex = null;
                    while (hitObject && !hitAlex) {
                        if (hitObject.userData && hitObject.userData.alexInstance) { hitAlex = hitObject.userData.alexInstance; }
                        hitObject = hitObject.parent;
                    }
                    if (hitAlex) { hitAlex.takeDamage(knifeDamage); }
                }
            }
            setTimeout(() => { isKnifeReady = true; }, knifeCooldown);
        }

        /** Gère l'action de rechargement du joueur. */
        function performReload() {
            if (isReloading || totalReserveAmmo <= 0 || currentAmmo === magazineCapacity) { return; }
            isReloading = true; ammoDisplay.classList.add('reloading'); showMessage("Rechargement...", reloadDuration);

            const initialArmPos = armMesh.position.clone();
            const reloadArmPos = new THREE.Vector3(initialArmPos.x, initialArmPos.y - 0.3, initialArmPos.z);
            const initialArmRot = armMesh.rotation.clone();
            const reloadArmRot = new THREE.Euler(initialArmRot.x + 0.3, initialArmRot.y, initialArmRot.z);
            let startTime = performance.now();
            const reloadDownDuration = reloadDuration * 0.3;
            const reloadUpDuration = reloadDuration * 0.7;

            function animateReload() {
                if (!armMesh || !gameActive) return; // Stop animation if armMesh is gone or game is not active
                const elapsed = performance.now() - startTime; let progress = 0;
                if (elapsed < reloadDownDuration) {
                    progress = elapsed / reloadDownDuration;
                    armMesh.position.lerpVectors(initialArmPos, reloadArmPos, progress);
                    armMesh.rotation.set(THREE.MathUtils.lerp(initialArmRot.x, reloadArmRot.x, progress),
                                         THREE.MathUtils.lerp(initialArmRot.y, reloadArmRot.y, progress),
                                         THREE.MathUtils.lerp(initialArmRot.z, reloadArmRot.z, progress));
                } else if (elapsed < reloadDuration) {
                    progress = (elapsed - reloadDownDuration) / reloadUpDuration;
                    armMesh.position.lerpVectors(reloadArmPos, initialArmPos, progress);
                    armMesh.rotation.set(THREE.MathUtils.lerp(reloadArmRot.x, initialArmRot.x, progress),
                                         THREE.MathUtils.lerp(reloadArmRot.y, initialArmRot.y, progress),
                                         THREE.MathUtils.lerp(reloadArmRot.z, initialArmRot.z, progress));
                } else {
                    armMesh.position.copy(initialArmPos); armMesh.rotation.copy(initialArmRot);
                    const bulletsToReload = magazineCapacity - currentAmmo;
                    const actualReloaded = Math.min(bulletsToReload, totalReserveAmmo);
                    currentAmmo += actualReloaded; totalReserveAmmo -= actualReloaded;
                    isReloading = false; ammoDisplay.classList.remove('reloading'); updateAmmoDisplay();
                    showMessage("Rechargé !", 1000); return;
                }
                requestAnimationFrame(animateReload);
            }
            animateReload();
        }

        /** Met à jour l'affichage des munitions dans l'interface utilisateur. */
        function updateAmmoDisplay() { ammoDisplay.textContent = `${currentAmmo} / ${totalReserveAmmo}`; }

        /** Met à jour l'affichage de la barre de vie. */
        function updateHealthDisplay() {
            const healthPercentage = (playerHealth / maxPlayerHealth) * 100;
            healthBar.style.width = `${healthPercentage}%`;
            healthBar.textContent = `${Math.round(playerHealth)} HP`;
            healthBar.style.backgroundColor = '#e53e3e'; // Red color for health bar
        }

        /** Classe pour créer un Alex (ennemi). */
        class Alex {
            /**
             * @param {number} x Position X initiale.
             * @param {number} y Position Y initiale.
             * @param {number} z Position Z initiale.
             * @param {number} health Santé d'Alex.
             * @param {number} speed Vitesse de déplacement d'Alex.
             * @param {number} damage Dégâts d'attaque d'Alex.
             * @param {THREE.Scene} scene La scène Three.js à laquelle ajouter Alex.
             * @param {THREE.Object3D} player L'objet Three.js du joueur (playerContainer) à cibler.
             */
            constructor(x, y, z, health, speed, damage, scene, player) {
                this.health = health; this.maxHealth = health; this.speed = speed; this.damage = damage;
                this.attackCooldown = ALEX_ATTACK_COOLDOWN; this.lastAttackTime = 0;
                this.scene = scene; this.player = player;

                this.mesh = new THREE.Group(); this.mesh.userData.alexInstance = this;
                const headGeo = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                const headMat = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.6, metalness: 0.1 });
                const head = new THREE.Mesh(headGeo, headMat); head.position.y = 1.3; this.mesh.add(head);
                const bodyGeo = new THREE.BoxGeometry(1, 1.2, 0.6);
                const bodyMat = new THREE.MeshStandardMaterial({ color: 0x32CD32, roughness: 0.6, metalness: 0.1 });
                const body = new THREE.Mesh(bodyGeo, bodyMat); body.position.y = 0.5; this.mesh.add(body);
                const armGeo = new THREE.BoxGeometry(0.4, 1, 0.4);
                const armMat = new THREE.MeshStandardMaterial({ color: 0x50C878, roughness: 0.6, metalness: 0.1 });
                const leftArm = new THREE.Mesh(armGeo, armMat); leftArm.position.set(-0.7, 0.5, 0); this.mesh.add(leftArm);
                const rightArm = new THREE.Mesh(armGeo, armMat); rightArm.position.set(0.7, 0.5, 0); this.mesh.add(rightArm);
                const legGeo = new THREE.BoxGeometry(0.4, 1, 0.4);
                const legMat = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.6, metalness: 0.1 });
                const leftLeg = new THREE.Mesh(legGeo, legMat); leftLeg.position.set(-0.25, -0.5, 0); this.mesh.add(leftLeg);
                const rightLeg = new THREE.Mesh(legGeo, legMat); rightLeg.position.set(0.25, -0.5, 0); this.mesh.add(rightLeg);
                this.mesh.position.set(x, 1.0, z); scene.add(this.mesh); // Alex's center is at 1.0 (total height 2.0)

                this.healthCanvas = document.createElement('canvas');
                this.healthCanvas.width = 128; this.healthCanvas.height = 32;
                this.healthContext = this.healthCanvas.getContext('2d');
                this.healthTexture = new THREE.CanvasTexture(this.healthCanvas);
                this.healthTexture.minFilter = THREE.LinearFilter;
                this.healthSpriteMaterial = new THREE.SpriteMaterial({ map: this.healthTexture });
                this.healthSprite = new THREE.Sprite(this.healthSpriteMaterial);
                this.healthSprite.scale.set(2, 0.5, 1); this.healthSprite.position.y = 2.0; // Position above Alex's head
                this.mesh.add(this.healthSprite); this.updateHealthSprite();
            }

            /**
             * Met à jour la logique d'Alex à chaque trame.
             * @param {number} deltaTime Temps écoulé depuis la dernière trame.
             */
            update(deltaTime) {
                if (!gameActive) return;

                const playerPos = this.player.position;
                const alexPos = this.mesh.position;
                let directionToPlayer = new THREE.Vector3().subVectors(playerPos, alexPos);
                directionToPlayer.y = 0; // Ignore Y-axis for horizontal movement
                directionToPlayer.normalize();

                const currentDistanceToPlayer = alexPos.distanceTo(playerPos);
                const moveAmount = this.speed * deltaTime;
                let desiredMovementVector = directionToPlayer.clone().multiplyScalar(moveAmount);
                const nextAlexPosition = alexPos.clone().add(desiredMovementVector);

                let collisionWithObstacle = false;
                let obstacleNormal = new THREE.Vector3();

                // Check collision with collidableObjects (excluding ground)
                for (const obj of collidableObjects) {
                    if (obj === ground) continue;

                    // Create a bounding box for Alex at the *next* intended position
                    const alexBoundingBox = new THREE.Box3().setFromCenterAndSize(
                        nextAlexPosition, new THREE.Vector3(ALEX_COLLISION_RADIUS * 2, 2, ALEX_COLLISION_RADIUS * 2)
                    );

                    // Ensure the object has a bounding box
                    if (!obj.geometry.boundingBox) {
                        obj.geometry.computeBoundingBox();
                    }
                    const objBox = obj.geometry.boundingBox.clone().applyMatrix4(obj.matrixWorld);

                    if (alexBoundingBox.intersectsBox(objBox)) {
                        collisionWithObstacle = true;
                        // Calculate a push-out vector to resolve the collision
                        const overlapVector = alexBoundingBox.getCenter(new THREE.Vector3()).sub(objBox.getCenter(new THREE.Vector3()));
                        overlapVector.y = 0; // Only consider horizontal push
                        overlapVector.normalize();
                        obstacleNormal.copy(overlapVector); // Store normal for sliding
                        break; // Found a collision, no need to check others for this Alex
                    }
                }

                if (collisionWithObstacle) {
                    // Try to slide along the obstacle
                    // Project the desired movement vector onto the plane perpendicular to the obstacle normal
                    desiredMovementVector.projectOnVector(obstacleNormal.negate());
                    this.mesh.position.add(desiredMovementVector); // Move Alex
                } else if (currentDistanceToPlayer > ALEX_ATTACK_RANGE_THRESHOLD) {
                    // If no obstacle and not close enough to attack, move towards player
                    this.mesh.position.add(desiredMovementVector);
                }

                // Alex always faces the player
                const angle = Math.atan2(directionToPlayer.x, directionToPlayer.z);
                this.mesh.rotation.y = angle;

                // Ground alignment for Alex
                const alexGroundRaycaster = new THREE.Raycaster(
                    this.mesh.position.clone().add(new THREE.Vector3(0, 1.0, 0)), // Start ray at Alex's approximate head level
                    new THREE.Vector3(0, -1, 0), // Downwards
                    0, 2.0 // Check up to 2 units below Alex's current Y
                );
                const alexGroundIntersects = alexGroundRaycaster.intersectObjects(collidableObjects, true);

                if (alexGroundIntersects.length > 0) {
                    const groundPoint = alexGroundIntersects[0].point;
                    this.mesh.position.y = groundPoint.y + 1.0; // Alex's feet should be at ground level (Alex's height is 2.0, so center is 1.0 above ground)
                } else {
                    // If no ground detected, assume default ground level or fall (if map allows)
                    // For this map, assume ground is always at Y=0, so Alex's center should be at Y=1.0
                    this.mesh.position.y = 1.0;
                }

                // Alex attack logic
                if (currentDistanceToPlayer <= ALEX_ATTACK_RANGE_THRESHOLD) { this.attackPlayer(); }
            }

            /**
             * Gère les dégâts subis par Alex.
             * @param {number} amount Le montant des dégâts à subir.
             */
            takeDamage(amount) {
                this.health -= amount; if (this.health < 0) this.health = 0;
                // Visual feedback for damage (flash red)
                this.mesh.traverse((object) => {
                    if (object.isMesh) {
                        object.material.emissive.setHex(0xFF0000);
                        setTimeout(() => { object.material.emissive.setHex(0x000000); }, 100);
                    }
                });
                this.updateHealthSprite();
                if (this.health <= 0) { this.die(); }
            }

            /** Met à jour le sprite de la barre de vie au-dessus d'Alex. */
            updateHealthSprite() {
                const canvas = this.healthCanvas; const ctx = this.healthContext;
                const width = canvas.width; const height = canvas.height;
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(0, 0, width, height); // Changed healthWidth to width
                const healthWidth = (this.health / this.maxHealth) * width;
                ctx.fillStyle = '#e53e3e'; ctx.fillRect(0, 0, healthWidth, height);
                ctx.fillStyle = 'white'; ctx.font = 'bold 20px Inter'; ctx.textAlign = 'center';
                ctx.textBaseline = 'middle'; ctx.fillText(`${Math.round(this.health)} HP`, width / 2, height / 2);
                this.healthTexture.needsUpdate = true;
            }

            /** Alex attaque le joueur. */
            attackPlayer() {
                const currentTime = performance.now();
                if (currentTime - this.lastAttackTime >= this.attackCooldown) {
                    if (playerDamageCooldown <= 0) { // Check player invincibility cooldown
                        playerHealth -= this.damage;
                        updateHealthDisplay();
                        playerDamageCooldown = playerDamageCooldownDuration; // Reset player damage cooldown
                    }
                    this.lastAttackTime = currentTime;
                }
            }

            /** Gère la mort d'Alex. */
            die() {
                this.scene.remove(this.mesh);
                // Dispose of Alex's mesh components to prevent memory leaks
                this.mesh.traverse((object) => {
                    if (object.isMesh) {
                        if (object.geometry) object.geometry.dispose();
                        if (object.material) {
                            if (Array.isArray(object.material)) {
                                object.material.forEach(m => m.dispose());
                            } else {
                                object.material.dispose();
                            }
                        }
                    }
                });

                if (this.healthSprite) {
                    this.mesh.remove(this.healthSprite);
                    if (this.healthSprite.material) this.healthSprite.material.dispose();
                    if (this.healthSprite.geometry) this.healthSprite.geometry.dispose();
                    if (this.healthTexture) this.healthTexture.dispose();
                }
                alexes = alexes.filter(a => a !== this); // Remove from active Alexes list
                alexesKilledThisWave++; totalAlexesKilledOverall++; updateWaveInfoDisplay();
                if (alexes.length === 0) {
                    showMessage(`Manche ${currentWave} terminée ! Préparation de la prochaine vague...`, timeBetweenWaves);
                    waveSpawnTimer = setTimeout(startNextWave, timeBetweenWaves); // Start next wave after delay
                }
            }
        }

        /** Réinitialise l'état du jeu pour une nouvelle partie. */
        function resetGame() {
            // Dispose of all existing Alexes
            alexes.forEach(alex => {
                scene.remove(alex.mesh);
                alex.mesh.traverse((object) => {
                    if (object.isMesh) {
                        if (object.geometry) object.geometry.dispose();
                        if (object.material) {
                            if (Array.isArray(object.material)) {
                                object.material.forEach(m => m.dispose());
                            } else {
                                object.material.dispose();
                            }
                        }
                    }
                });
                if (alex.healthSprite) {
                    alex.mesh.remove(alex.healthSprite);
                    if (alex.healthSprite.material) alex.healthSprite.material.dispose();
                    if (alex.healthSprite.geometry) alex.healthSprite.geometry.dispose();
                    if (alex.healthTexture) alex.healthTexture.dispose();
                }
            });

            alexes = []; // Clear Alexes array
            playerHealth = maxPlayerHealth; currentAmmo = magazineCapacity;
            totalReserveAmmo = 90; isReloading = false; isKnifeReady = true; canJump = true;
            playerVerticalVelocity = 0; playerDamageCooldown = 0; currentWave = 0;
            alexesKilledThisWave = 0; totalAlexesKilledOverall = 0;

            playerContainer.position.set(0, playerHeight, 0); // Player starting position (at playerHeight above ground Y=0)
            camera.rotation.set(0, 0, 0); // Reset camera rotation

            updateAmmoDisplay(); updateHealthDisplay(); updateWaveInfoDisplay();

            // Reset weapon/arm position
            if (armMesh) { armMesh.position.set(0.5, -0.7, -1.0); armMesh.rotation.x = -Math.PI / 6; armMesh.rotation.y = Math.PI / 8; }
            // Remove knife visual if it exists
            if (knifeVisual && knifeVisual.parent) { camera.remove(knifeVisual); knifeVisual = null; }

            // Clear any pending wave timers
            if (waveSpawnTimer) { clearTimeout(waveSpawnTimer); waveSpawnTimer = null; }

            // Start the first wave
            startNextWave();
        }

        /**
         * Fonction utilitaire pour créer un bloc.
         * @param {number} width Largeur du bloc.
         * @param {number} height Hauteur du bloc.
         * @param {number} depth Profondeur du bloc.
         * @param {THREE.Material} material Matériau du bloc.
         * @param {number} x Position X.
         * @param {number} y Position Y.
         * @param {number} z Position Z.
         */
        function createBlock(width, height, depth, material, x, y, z) {
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.geometry.computeBoundingBox(); // Compute bounding box for collision detection
            scene.add(mesh);
            collidableObjects.push(mesh);
            return mesh;
        }

        /** Génère la carte fixe de la centrale électrique. */
        function generatePowerPlant() {
            // Dispose of existing collidable objects before generating new ones
            collidableObjects.forEach(obj => {
                if (obj.parent) scene.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) {
                    if (Array.isArray(obj.material)) { obj.material.forEach(m => m.dispose()); }
                    else { obj.material.dispose(); }
                }
            });
            collidableObjects = []; // Clear the array

            const textureLoader = new THREE.TextureLoader();
            const wallTexture = textureLoader.load('https://placehold.co/512x512/4A5568/CBD5E0.png');
            wallTexture.wrapS = THREE.RepeatWrapping; wallTexture.wrapT = THREE.RepeatWrapping; wallTexture.repeat.set(5, 5);
            const metalTexture = textureLoader.load('https://placehold.co/512x512/2D3748/A0AEC0.png');
            metalTexture.wrapS = THREE.RepeatWrapping; metalTexture.wrapT = THREE.RepeatWrapping; metalTexture.repeat.set(3, 3);
            const floorTexture = textureLoader.load('https://placehold.co/1024x1024/303030/808080.png');
            floorTexture.wrapS = THREE.RepeatWrapping; floorTexture.wrapT = THREE.RepeatWrapping; floorTexture.repeat.set(5, 5);

            const concreteMaterial = new THREE.MeshStandardMaterial({ map: wallTexture, roughness: 0.7, metalness: 0.1 });
            const metalMaterial = new THREE.MeshStandardMaterial({ map: metalTexture, roughness: 0.3, metalness: 0.7 });
            const floorMaterial = new THREE.MeshStandardMaterial({ map: floorTexture, roughness: 0.8 });
            
            // Ground plane
            const groundGeometry = new THREE.PlaneGeometry(200, 200);
            ground = new THREE.Mesh(groundGeometry, floorMaterial);
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground); collidableObjects.push(ground); // Add ground to collidable objects

            // --- Bâtiment principal (Salle des turbines) ---
            mainHallX = 0; mainHallZ = 0; mainHallWidth = 60; mainHallDepth = 40; mainHallHeight = 15;
            wallThickness = 1;

            // Walls
            createBlock(wallThickness, mainHallHeight, mainHallDepth, concreteMaterial, mainHallX - mainHallWidth / 2 - wallThickness / 2, mainHallHeight / 2, mainHallZ); // Left wall
            createBlock(wallThickness, mainHallHeight, mainHallDepth, concreteMaterial, mainHallX + mainHallWidth / 2 + wallThickness / 2, mainHallHeight / 2, mainHallZ); // Right wall
            createBlock(mainHallWidth, mainHallHeight, wallThickness, concreteMaterial, mainHallX, mainHallHeight / 2, mainHallZ - mainHallDepth / 2 - wallThickness / 2); // Back wall

            // Front wall with openings (simplified)
            const entranceWidth = 10; const gap = 5;
            const totalEntranceZoneWidth = (entranceWidth * 3) + (gap * 2); // Total width of the three segments and two gaps
            const segmentWidth = (mainHallWidth - totalEntranceZoneWidth) / 2; // Remaining width for side segments
            
            // Left segment of front wall
            createBlock(segmentWidth, mainHallHeight, wallThickness, concreteMaterial, mainHallX - mainHallWidth / 2 + segmentWidth / 2, mainHallHeight / 2, mainHallZ + mainHallDepth / 2 + wallThickness / 2);
            // Three pillars/segments for entrance
            createBlock(entranceWidth, mainHallHeight, wallThickness, concreteMaterial, mainHallX - totalEntranceZoneWidth / 2 + entranceWidth / 2, mainHallHeight / 2, mainHallZ + mainHallDepth / 2 + wallThickness / 2);
            createBlock(entranceWidth, mainHallHeight, wallThickness, concreteMaterial, mainHallX - totalEntranceZoneWidth / 2 + entranceWidth / 2 + entranceWidth + gap, mainHallHeight / 2, mainHallZ + mainHallDepth / 2 + wallThickness / 2);
            createBlock(entranceWidth, mainHallHeight, wallThickness, concreteMaterial, mainHallX - totalEntranceZoneWidth / 2 + entranceWidth / 2 + (entranceWidth + gap) * 2, mainHallHeight / 2, mainHallZ + mainHallDepth / 2 + wallThickness / 2);
            // Right segment of front wall
            createBlock(segmentWidth, mainHallHeight, wallThickness, concreteMaterial, mainHallX + mainHallWidth / 2 - segmentWidth / 2, mainHallHeight / 2, mainHallZ + mainHallDepth / 2 + wallThickness / 2);


            // Ceiling
            createBlock(mainHallWidth + wallThickness * 2, wallThickness, mainHallDepth + wallThickness * 2, concreteMaterial, mainHallX, mainHallHeight + wallThickness / 2, mainHallZ);

            // Turbines
            const turbineY = 2;
            for (let i = -1; i <= 1; i++) {
                const turbine = new THREE.Mesh(new THREE.CylinderGeometry(3, 3, 10, 32), metalMaterial);
                turbine.rotation.z = Math.PI / 2; // Rotate to be horizontal
                turbine.position.set(mainHallX + i * 15, turbineY + turbine.geometry.parameters.height / 2, mainHallZ - 10);
                scene.add(turbine); collidableObjects.push(turbine);
            }
            // Additional structures in main hall
            createBlock(2, 4, 2, metalMaterial, mainHallX + 10, 2, mainHallZ + 15);
            createBlock(2, 4, 2, metalMaterial, mainHallX - 10, 2, mainHallZ + 15);

            // --- Bâtiment de la chaudière ---
            boilerHallX = mainHallX + mainHallWidth / 2 + wallThickness + 30; // Further away
            boilerHallZ = mainHallZ;
            boilerWidth = 30; // Wider
            boilerDepth = 30; // Deeper
            const floorHeight = 5; // Height of each floor
            const numBoilerFloors = 6;
            const totalBoilerHeight = floorHeight * numBoilerFloors;

            // Boiler building shell (walls and roof)
            createBlock(boilerWidth + wallThickness * 2, totalBoilerHeight + wallThickness * 2, boilerDepth + wallThickness * 2, concreteMaterial, boilerHallX, (totalBoilerHeight / 2) + wallThickness, boilerHallZ); // Outer shell for full height
            
            // Internal floors
            for (let i = 1; i < numBoilerFloors; i++) { // Start from first floor (i=1) up to 5th (i=numBoilerFloors-1)
                createBlock(boilerWidth - wallThickness * 2, wallThickness, boilerDepth - wallThickness * 2, floorMaterial, boilerHallX, (i * floorHeight) + wallThickness / 2, boilerHallZ);
            }
            
            // Large cylindrical boiler in the center
            const mainBoiler = new THREE.Mesh(new THREE.CylinderGeometry(8, 8, totalBoilerHeight + 2, 32), metalMaterial); // Make it slightly taller
            mainBoiler.position.set(boilerHallX, (totalBoilerHeight / 2) + 1, boilerHallZ);
            scene.add(mainBoiler); collidableObjects.push(mainBoiler);

            // Redesigned staircase (spiral around the boiler, no overlap)
            const stairRadius = 10; // Radius from the boiler center
            const stairWidth = 3;
            const stairDepth = 5;
            const stepsPerFloor = 5;
            const totalSteps = numBoilerFloors * stepsPerFloor;
            const anglePerStep = (Math.PI * 2) / stepsPerFloor; // Full circle per floor (simplified spiral)

            for (let i = 0; i < totalSteps; i++) {
                const currentFloor = Math.floor(i / stepsPerFloor);
                const stepAngle = i * anglePerStep;
                // Corrected: stepsPerStep was a typo, should be stepsPerFloor
                const stepY = (currentFloor * floorHeight) + ((i % stepsPerFloor) * (floorHeight / stepsPerFloor)) + (wallThickness / 2); // Progressive climb
                
                const stepX = boilerHallX + stairRadius * Math.sin(stepAngle);
                const stepZ = boilerHallZ + stairRadius * Math.cos(stepAngle);

                const step = createBlock(stairWidth, 0.5, stairDepth, metalMaterial, stepX, stepY + 0.25, stepZ); // 0.5 is step height
                step.rotation.y = stepAngle; // Orient the step towards the center
            }


            // --- Connection tunnel between the two buildings ---
            const tunnelLengthBetween = 15;
            createBlock(tunnelLengthBetween, mainHallHeight, entranceWidth, concreteMaterial, mainHallX + mainHallWidth / 2 + wallThickness + tunnelLengthBetween / 2, mainHallHeight / 2, mainHallZ);
            createBlock(tunnelLengthBetween, wallThickness, entranceWidth, floorMaterial, mainHallX + mainHallWidth / 2 + wallThickness + tunnelLengthBetween / 2, wallThickness / 2, mainHallZ);

            // Some random small obstacles/structures for cover
            createBlock(1, 10, 1, metalMaterial, boilerHallX + 5, 5, boilerHallZ + 5);
        }


        /** Démarre la prochaine vague d'ennemis. */
        function startNextWave() {
            currentWave++; alexesKilledThisWave = 0;
            // Dispose of all existing Alexes from previous wave
            alexesInCurrentWave.forEach(alex => {
                scene.remove(alex.mesh);
                alex.mesh.traverse((object) => {
                    if (object.isMesh) {
                        if (object.geometry) object.geometry.dispose();
                        if (object.material) {
                            if (Array.isArray(object.material)) {
                                object.material.forEach(m => m.dispose());
                            } else {
                                object.material.dispose();
                            }
                        }
                    }
                });
                if (alex.healthSprite) {
                    alex.mesh.remove(alex.healthSprite);
                    if (alex.healthSprite.material) alex.healthSprite.material.dispose();
                    if (alex.healthSprite.geometry) alex.healthSprite.geometry.dispose();
                    if (alex.healthTexture) alex.healthTexture.dispose();
                }
            });
            alexesInCurrentWave = []; // Clear current wave Alexes
            alexes = []; // Ensure global alexes array is also cleared

            const numAlexThisWave = 5 + (currentWave * 2); // Number of Alexes increases with wave
            showMessage(`Manche ${currentWave} ! Préparez-vous !`, 2000);

            // Define potential spawn zones
            const spawnZonePositions = [
                new THREE.Vector3(mainHallX, 0, mainHallZ - mainHallDepth / 2 - wallThickness - 10), // Behind main hall
                new THREE.Vector3(mainHallX, 0, mainHallZ + mainHallDepth / 2 + wallThickness + 10), // In front of main hall
                new THREE.Vector3(mainHallX - mainHallWidth / 2 - wallThickness - 10, 0, mainHallZ), // Left of main hall
                new THREE.Vector3(mainHallX + mainHallWidth / 2 + wallThickness + 10, 0, mainHallZ), // Right of main hall
                new THREE.Vector3(boilerHallX, 0, boilerHallZ - boilerDepth / 2 - wallThickness - 10), // Behind boiler building
                new THREE.Vector3(boilerHallX, 0, boilerHallZ + boilerDepth / 2 + wallThickness + 10), // In front of boiler building
                new THREE.Vector3(boilerHallX - boilerWidth / 2 - wallThickness - 10, 0, boilerHallZ), // Left of boiler building
                new THREE.Vector3(boilerHallX + boilerWidth / 2 + wallThickness + 10, 0, boilerHallZ) // Right of boiler building
            ];
            spawnAreaRadius = 40; // General radius for random spawns if specific zones fail

            for (let i = 0; i < numAlexThisWave; i++) {
                const alexHealth = Math.round(ALEX_BASE_HEALTH * (1 + (currentWave * 0.1)));
                const alexSpeed = ALEX_BASE_SPEED * (1 + (currentWave * 0.005));
                const alexDamage = ALEX_BASE_DAMAGE * (1 + (currentWave * 0.01));

                let spawnX, spawnZ;
                let validSpawnFound = false;
                const maxSpawnAttempts = 50; // Increased attempts for robustness

                for (let attempt = 0; attempt < maxSpawnAttempts; attempt++) {
                    const spawnIndex = Math.floor(Math.random() * spawnZonePositions.length);
                    const baseSpawn = spawnZonePositions[spawnIndex];
                    spawnX = baseSpawn.x + (Math.random() - 0.5) * 10; // Random offset from base spawn point
                    spawnZ = baseSpawn.z + (Math.random() - 0.5) * 10;

                    const spawnPosition = new THREE.Vector3(spawnX, 1.0, spawnZ); // Assume Alex height is 2.0, so center is 1.0
                    const distanceToPlayer = spawnPosition.distanceTo(playerContainer.position);

                    if (distanceToPlayer < 15) { // Ensure Alex doesn't spawn too close to the player
                        continue;
                    }

                    // Check for intersection with existing structures
                    const alexBoundingBox = new THREE.Box3().setFromCenterAndSize(
                        spawnPosition, new THREE.Vector3(ALEX_COLLISION_RADIUS * 2, 2, ALEX_COLLISION_RADIUS * 2)
                    );

                    let intersectionWithStructure = false;
                    for (const obj of collidableObjects) {
                        if (obj === ground) continue; // Don't check against ground for structural intersection
                        if (!obj.geometry.boundingBox) { obj.geometry.computeBoundingBox(); }
                        const objBox = obj.geometry.boundingBox.clone().applyMatrix4(obj.matrixWorld);
                        if (alexBoundingBox.intersectsBox(objBox)) {
                            intersectionWithStructure = true;
                            break;
                        }
                    }
                    if (intersectionWithStructure) {
                        continue;
                    }

                    // Check if the spawn position is on the ground (raycast downwards)
                    const tempAlexRaycaster = new THREE.Raycaster(spawnPosition.clone().add(new THREE.Vector3(0, 5, 0)), new THREE.Vector3(0, -1, 0), 0, 10);
                    const intersections = tempAlexRaycaster.intersectObjects(collidableObjects, true);
                    const hitGround = intersections.some(intersect => intersect.object === ground);
                    if (!hitGround) {
                        continue; // Must spawn on ground
                    }

                    validSpawnFound = true;
                    break; // Valid spawn found, break from attempt loop
                }

                if (!validSpawnFound) {
                    // Fallback: if after many attempts, no valid spot found, just place it somewhere,
                    // this should be rare with increased attempts.
                    console.warn("Could not find a valid spawn point for Alex after multiple attempts. Placing at a default fallback.");
                    spawnX = (Math.random() - 0.5) * (spawnAreaRadius * 1.5);
                    spawnZ = (Math.random() - 0.5) * (spawnAreaRadius * 1.5);
                }

                const alex = new Alex(spawnX, 1.0, spawnZ, alexHealth, alexSpeed, alexDamage, scene, playerContainer);
                alexes.push(alex);
                alexesInCurrentWave.push(alex);
            }
            updateWaveInfoDisplay();
        }

        /** Met à jour l'affichage des informations de vague. */
        function updateWaveInfoDisplay() {
            currentWaveDisplay.textContent = currentWave;
            alexesRemainingDisplay.textContent = alexes.length;
        }

        /** Termine la partie. */
        function endGame() {
            gameActive = false; currentUIMode = 'gameOver'; document.exitPointerLock();
            // Hide all game UI elements
            mainMenuDiv.style.display = 'none'; settingsSection.style.display = 'none';
            pauseMenu.style.display = 'none'; quitConfirmModal.style.display = 'none';
            gameContainer.style.display = 'none'; infoBox.style.display = 'none';
            ammoDisplay.style.display = 'none'; healthDisplay.style.display = 'none';
            waveInfo.style.display = 'none'; shootingEffectElements.forEach(el => el.style.display = 'none');
            // Show game over screen
            gameOverScreen.style.display = 'flex';
            finalAlexKillsDisplay.textContent = totalAlexesKilledOverall;
            finalWavesSurvivedDisplay.textContent = currentWave;
            // Clear any pending wave timers
            if (waveSpawnTimer) { clearTimeout(waveSpawnTimer); waveSpawnTimer = null; }
        }

        /** Boucle d'animation principale. */
        function animate() {
            requestAnimationFrame(animate);
            const currentTime = performance.now();
            const deltaTime = (currentTime - lastFrameTime) / 1000; // Convert to seconds
            lastFrameTime = currentTime;
            
            if (gameActive) {
                // Player movement
                let moveVector = new THREE.Vector3();
                const forwardDir = new THREE.Vector3(); camera.getWorldDirection(forwardDir);
                forwardDir.y = 0; forwardDir.normalize();
                const rightDir = new THREE.Vector3(); rightDir.setFromMatrixColumn(camera.matrixWorld, 0);
                rightDir.y = 0; rightDir.normalize();

                if (keyboard[keyBindings.moveForward]) { moveVector.add(forwardDir); }
                if (keyboard[keyBindings.moveBackward]) { moveVector.sub(forwardDir); }
                if (keyboard[keyBindings.strafeLeft]) { moveVector.sub(rightDir); }
                if (keyboard[keyBindings.strafeRight]) { moveVector.add(rightDir); }

                if (moveVector.lengthSq() > 0) { // Check if there's actual horizontal movement
                    moveVector.normalize().multiplyScalar(moveSpeed * deltaTime); // Apply movement speed and delta time
                    playerContainer.position.add(moveVector); // Tentatively move the player

                    // Now check for collisions with static objects and resolve by pushing out
                    const playerBoundingSphere = new THREE.Sphere(playerContainer.position, playerCollisionRadius);

                    for (const obj of collidableObjects) {
                        if (obj === ground) continue; // Don't collide horizontally with ground

                        if (!obj.geometry.boundingBox) {
                            obj.geometry.computeBoundingBox();
                        }
                        const objBox = obj.geometry.boundingBox.clone().applyMatrix4(obj.matrixWorld);

                        // Check for intersection between player sphere and object bounding box
                        if (playerBoundingSphere.intersectsBox(objBox)) {
                            // Calculate penetration vector
                            const intersectionPoint = playerBoundingSphere.center.clone();
                            objBox.clampPoint(intersectionPoint, intersectionPoint); // Clamp player center to the closest point on the box

                            const penetrationVector = playerBoundingSphere.center.clone().sub(intersectionPoint);
                            penetrationVector.y = 0; // Only resolve horizontal collisions

                            const distance = penetrationVector.length();
                            if (distance < playerCollisionRadius) {
                                const overlap = playerCollisionRadius - distance;
                                if (distance === 0) { // If player is exactly at the center of the box (unlikely but handle)
                                    penetrationVector.x = (Math.random() - 0.5) * 0.1;
                                    penetrationVector.z = (Math.random() - 0.5) * 0.1;
                                    penetrationVector.normalize();
                                } else {
                                    penetrationVector.normalize();
                                }
                                playerContainer.position.add(penetrationVector.multiplyScalar(overlap + 0.01)); // Push player out
                            }
                        }
                    }
                }
                
                // Player-Alex collision and push-out (horizontal)
                alexes.forEach(alex => {
                    const combinedRadius = playerCollisionRadius + ALEX_COLLISION_RADIUS;
                    const distanceVector = new THREE.Vector3().subVectors(playerContainer.position, alex.mesh.position);
                    distanceVector.y = 0; // Only consider horizontal distance

                    const currentDistance = distanceVector.length();
                    if (currentDistance < combinedRadius) {
                        const overlap = combinedRadius - currentDistance;
                        if (currentDistance === 0) { // Avoid division by zero if positions are identical
                            distanceVector.x = (Math.random() - 0.5) * 0.1;
                            distanceVector.z = (Math.random() - 0.5) * 0.1;
                            distanceVector.normalize();
                        } else {
                            distanceVector.normalize();
                        }
                        playerContainer.position.add(distanceVector.multiplyScalar(overlap + 0.01)); // Push player out
                    }
                });

                // Vertical movement (Y-axis) including gravity and ground collision
                playerVerticalVelocity += gravity * deltaTime; // Apply gravity with deltaTime
                playerContainer.position.y += playerVerticalVelocity * deltaTime; // Apply vertical velocity with deltaTime

                // Raycast downwards from player's feet to detect ground
                const playerFeetY = playerContainer.position.y - playerHeight; // Player's feet Y coordinate
                const rayOriginY = playerFeetY + 0.1; // Start ray slightly above feet
                const rayOrigin = new THREE.Vector3(playerContainer.position.x, rayOriginY, playerContainer.position.z);
                const rayDirection = new THREE.Vector3(0, -1, 0); // Downwards

                raycaster.set(rayOrigin, rayDirection);
                // The "far" value should cover the distance player falls in this frame + max step height + a small buffer
                raycaster.far = Math.abs(playerVerticalVelocity * deltaTime) + playerStepHeight + 0.1;

                const groundIntersects = raycaster.intersectObjects(collidableObjects, true);

                let landedOnGround = false;
                if (groundIntersects.length > 0) {
                    const closestGroundHit = groundIntersects[0];
                    const targetPlayerY = closestGroundHit.point.y + playerHeight; // Target playerContainer.position.y (eye level)

                    // Only land if falling or if the step is within playerStepHeight
                    if (playerVerticalVelocity < 0 || (targetPlayerY > playerContainer.position.y && targetPlayerY - playerContainer.position.y <= playerStepHeight)) {
                        playerContainer.position.y = targetPlayerY;
                        playerVerticalVelocity = 0;
                        canJump = true;
                        landedOnGround = true;
                    }
                }

                if (!landedOnGround) {
                    canJump = false; // Cannot jump if not firmly on ground
                    // If player is not on ground and not falling, start falling (e.g., walked off a platform)
                    if (playerVerticalVelocity === 0 && playerContainer.position.y > playerHeight + 0.01) { // Add small buffer to avoid re-triggering immediately
                        playerVerticalVelocity = gravity * deltaTime;
                    }
                }

                // Absolute restriction to prevent falling through the lowest point of the world (ground Y=0)
                if (playerContainer.position.y < playerHeight) {
                    playerContainer.position.y = playerHeight;
                    playerVerticalVelocity = 0;
                    canJump = true;
                }

                // Update Alexes
                alexes.forEach(alex => alex.update(deltaTime));

                // Update player damage cooldown
                if (playerDamageCooldown > 0) {
                    playerDamageCooldown -= deltaTime * 1000; // Decrease by milliseconds
                    if (playerDamageCooldown < 0) playerDamageCooldown = 0;
                }

                // Check for game over
                if (playerHealth <= 0) {
                    endGame();
                }
            }
            renderer.render(scene, camera);
        }

        // --- Fonctions de gestion des écrans ---

        /** Affiche l'écran du menu principal. */
        function showMenuScreen() {
            currentUIMode = 'mainMenu'; mainMenuDiv.style.display = 'flex';
            document.getElementById('main-menu-title').style.display = 'block';
            document.getElementById('menu-buttons-container').style.display = 'flex';
            settingsSection.style.display = 'none'; pauseMenu.style.display = 'none';
            quitConfirmModal.style.display = 'none'; gameContainer.style.display = 'none';
            infoBox.style.display = 'none'; ammoDisplay.style.display = 'none';
            healthDisplay.style.display = 'none'; waveInfo.style.display = 'none';
            gameOverScreen.style.display = 'none'; gameActive = false;
            updateKeyRemapButtons(); // Ensure key remapping buttons show current keys
            shootingEffectElements.forEach(el => el.style.display = 'block'); // Show menu background effects
        }

        /** Affiche l'écran des paramètres. */
        function showSettingsScreen() {
            previousUIMode = currentUIMode; currentUIMode = 'settings';
            mainMenuDiv.style.display = 'flex'; // Keep main menu container visible for settings
            document.getElementById('main-menu-title').style.display = 'none';
            document.getElementById('menu-buttons-container').style.display = 'none';
            settingsSection.style.display = 'flex'; pauseMenu.style.display = 'none';
            quitConfirmModal.style.display = 'none'; gameContainer.style.display = 'none';
            infoBox.style.display = 'none'; ammoDisplay.style.display = 'none';
            healthDisplay.style.display = 'none'; waveInfo.style.display = 'none';
            gameOverScreen.style.display = 'none'; gameActive = false;
            shootingEffectElements.forEach(el => el.style.display = 'none'); // Hide menu background effects in settings
            if (sensitivitySlider && currentSensitivityDisplay) {
                sensitivitySlider.value = rotationSpeed;
                currentSensitivityDisplay.textContent = rotationSpeed.toFixed(4);
            }
            updateKeyRemapButtons();
        }

        /** Affiche le menu de pause. */
        function showPauseMenu() {
            previousUIMode = currentUIMode; currentUIMode = 'pauseMenu';
            pauseMenu.style.display = 'flex'; mainMenuDiv.style.display = 'none';
            settingsSection.style.display = 'none'; gameContainer.style.display = 'none';
            infoBox.style.display = 'none'; ammoDisplay.style.display = 'none';
            healthDisplay.style.display = 'none'; waveInfo.style.display = 'none';
            gameOverScreen.style.display = 'none'; gameActive = false;
            shootingEffectElements.forEach(el => el.style.display = 'none'); // Hide menu background effects in pause
        }

        /** Masque le menu de pause. */
        function hidePauseMenu() { pauseMenu.style.display = 'none'; }

        /** Affiche la modale de confirmation pour quitter. */
        function showQuitConfirm() {
            previousUIMode = currentUIMode; currentUIMode = 'quitConfirm';
            quitConfirmModal.style.display = 'flex'; pauseMenu.style.display = 'none';
        }

        /** Masque la modale de confirmation pour quitter. */
        function hideQuitConfirm() { quitConfirmModal.style.display = 'none'; }

        /**
         * Demande le verrouillage du pointeur pour le jeu.
         * @param {boolean} forceGameMode Si vrai, force le mode d'interface utilisateur à 'game'.
         */
        function requestGamePointerLock(forceGameMode = false) {
            if (isPointerLockRequested || document.pointerLockElement === gameContainer) {
                // If pointer lock is already requested or active, and we want to force game mode, update UI
                if (document.pointerLockElement === gameContainer && currentUIMode !== 'game' && forceGameMode) {
                    gameActive = true; currentUIMode = 'game';
                    mainMenuDiv.style.display = 'none'; settingsSection.style.display = 'none';
                    pauseMenu.style.display = 'none'; quitConfirmModal.style.display = 'none';
                    gameOverScreen.style.display = 'none'; gameContainer.style.display = 'block';
                    infoBox.style.display = 'none'; ammoDisplay.style.display = 'block';
                    healthDisplay.style.display = 'block'; waveInfo.style.display = 'block';
                }
                return;
            }
            isPointerLockRequested = true;
            gameContainer.requestPointerLock()
                .then(() => { isPointerLockRequested = false; })
                .catch((e) => {
                    isPointerLockRequested = false;
                    // Handle cases where pointer lock fails (e.g., user gesture required, security error)
                    if (e.name === "SecurityError" || (e.message && e.message.includes("UserGesture"))) {
                        showMessage('Verrouillage de la souris annulé. Cliquez pour rejouer.', 3000);
                        // Go back to the previous UI mode, or main menu if no previous game state
                        if (previousUIMode === 'pauseMenu') { showPauseMenu(); }
                        else { showMenuScreen(); }
                    } else {
                        showMessage('Erreur de verrouillage de la souris. Retour au menu principal.', 3000);
                        showMenuScreen();
                    }
                });
        }

        /** Initialise le jeu. */
        function init() {
            // Scene setup
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x333333);
            
            // Player container (for horizontal movement and rotation)
            playerContainer = new THREE.Object3D();
            playerContainer.position.set(0, playerHeight, 0); // Player starting position (feet at Y=0, eyes at playerHeight)
            scene.add(playerContainer);

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 0); // Camera is at the center of playerContainer (which is player's eye level)
            playerContainer.add(camera);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('game-container').appendChild(renderer.domElement);

            playerVelocity = new THREE.Vector3(); // For player movement calculations

            // Get UI element references
            messageBox = document.getElementById('message-box'); crosshair = document.getElementById('crosshair');
            ammoDisplay = document.getElementById('ammo-display'); healthDisplay = document.getElementById('health-display');
            healthBar = document.getElementById('health-bar'); waveInfo = document.getElementById('wave-info');
            currentWaveDisplay = document.getElementById('current-wave-display');
            alexesRemainingDisplay = document.getElementById('alexes-remaining-display');
            
            mainMenuDiv = document.getElementById('main-menu'); gameContainer = document.getElementById('game-container');
            infoBox = document.getElementById('info-box');
            startGameButton = document.getElementById('start-game-button');
            mainMenuSettingsButton = document.getElementById('main-menu-settings-button');
            settingsSection = document.getElementById('settings-section');
            sensitivitySlider = document.getElementById('sensitivity-slider');
            currentSensitivityDisplay = document.getElementById('current-sensitivity');
            backToMainMenuButton = document.getElementById('back-to-main-menu-button');
            resetKeysButton = document.getElementById('reset-keys-button');
            pauseMenu = document.getElementById('pause-menu'); resumeButton = document.getElementById('resume-button');
            pauseSettingsButton = document.getElementById('pause-settings-button');
            quitToMainButton = document.getElementById('quit-to-main-button');
            quitConfirmModal = document.getElementById('quit-confirm-modal');
            confirmQuitYesButton = document.getElementById('confirm-quit-yes');
            confirmQuitNoButton = document.getElementById('confirm-quit-no');
            gameOverScreen = document.getElementById('game-over-screen');
            finalAlexKillsDisplay = document.getElementById('final-alex-kills');
            finalWavesSurvivedDisplay = document.getElementById('final-waves-survived');
            replayButton = document.getElementById('replay-button');

            // Event listeners for settings
            if (sensitivitySlider) {
                sensitivitySlider.value = rotationSpeed;
                sensitivitySlider.addEventListener('input', (event) => {
                    rotationSpeed = parseFloat(event.target.value);
                    if (currentSensitivityDisplay) { currentSensitivityDisplay.textContent = rotationSpeed.toFixed(4); }
                });
            }
            if (currentSensitivityDisplay) { currentSensitivityDisplay.textContent = rotationSpeed.toFixed(4); }

            // Key remapping buttons
            document.getElementById('remap-moveForward').addEventListener('click', (event) => startRemap('moveForward', event.target));
            document.getElementById('remap-moveBackward').addEventListener('click', (event) => startRemap('moveBackward', event.target));
            document.getElementById('remap-strafeLeft').addEventListener('click', (event) => startRemap('strafeLeft', event.target));
            document.getElementById('remap-strafeRight').addEventListener('click', (event) => startRemap('strafeRight', event.target));
            document.getElementById('remap-jump').addEventListener('click', (event) => startRemap('jump', event.target));
            document.getElementById('remap-knife').addEventListener('click', (event) => startRemap('knife', event.target));
            document.getElementById('remap-reload').addEventListener('click', (event) => startRemap('reload', event.target));
            
            if (resetKeysButton) { resetKeysButton.addEventListener('click', resetKeysToDefault); }

            // Pause menu buttons
            if (resumeButton) { resumeButton.addEventListener('click', () => { hidePauseMenu(); requestGamePointerLock(true); }); }
            if (pauseSettingsButton) { pauseSettingsButton.addEventListener('click', () => { hidePauseMenu(); showSettingsScreen(); }); }
            if (quitToMainButton) { quitToMainButton.addEventListener('click', showQuitConfirm); }

            // Quit confirmation modal buttons
            if (confirmQuitYesButton) { confirmQuitYesButton.addEventListener('click', () => { hideQuitConfirm(); showMenuScreen(); showMessage("Partie abandonnée. La progression a été perdue.", 3000); }); }
            if (confirmQuitNoButton) { confirmQuitNoButton.addEventListener('click', () => { hideQuitConfirm(); showPauseMenu(); }); }

            // Game Over screen button
            if (replayButton) { replayButton.addEventListener('click', () => { resetGame(); showMenuScreen(); }); } // Go back to main menu after replay

            // Add shooting effects to main menu background
            for (let i = 0; i < NUM_SHOOTING_EFFECTS; i++) {
                const flash = document.createElement('div');
                flash.classList.add('shooting-flash');
                flash.style.left = `${Math.random() * 100}vw`; flash.style.top = `${Math.random() * 100}vh`;
                flash.style.setProperty('--rand-x', (Math.random() - 0.5) * 2);
                flash.style.setProperty('--rand-y', (Math.random() - 0.5) * 2);
                flash.style.setProperty('--rand-delay', `${Math.random() * 2}s`);
                mainMenuDiv.appendChild(flash); shootingEffectElements.push(flash);
            }

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 2); scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7); scene.add(directionalLight);

            // Initial ground (will be replaced by generatePowerPlant)
            const textureLoader = new THREE.TextureLoader();
            const groundTexture = textureLoader.load('https://placehold.co/1024x1024/303030/808080.png');
            groundTexture.wrapS = THREE.RepeatWrapping; groundTexture.wrapT = THREE.RepeatWrapping; groundTexture.repeat.set(20, 20);
            const groundGeometry = new THREE.PlaneGeometry(200, 200);
            const groundMaterial = new THREE.MeshStandardMaterial({ map: groundTexture, roughness: 0.8, metalness: 0.2 });
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground); collidableObjects.push(ground);
            
            // Generate the power plant map
            generatePowerPlant();

            // Player's arm and weapon visual
            const armMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
            const weaponMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.7, metalness: 0.5 });
            const forearmGeometry = new THREE.BoxGeometry(0.35, 0.35, 1.2);
            armMesh = new THREE.Mesh(forearmGeometry, armMaterial);
            armMesh.position.set(0.5, -0.7, -1.0); // Offset from camera for first-person view
            armMesh.rotation.x = -Math.PI / 6; armMesh.rotation.y = Math.PI / 8;
            camera.add(armMesh);
            const weaponBodyGeometry = new THREE.BoxGeometry(0.18, 0.18, 1.0);
            weaponMesh = new THREE.Mesh(weaponBodyGeometry, weaponMaterial);
            weaponMesh.position.set(0, 0, -0.4); armMesh.add(weaponMesh);
            const weaponBarrelGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.5, 8);
            const weaponBarrelMesh = new THREE.Mesh(weaponBarrelGeometry, weaponMaterial);
            weaponBarrelMesh.position.set(0, 0, -0.6); weaponBarrelMesh.rotation.x = Math.PI / 2;
            weaponMesh.add(weaponBarrelMesh);

            // Debug ray line (for visualizing shooting/knife raycasts)
            const rayMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
            const rayPoints = []; rayPoints.push(new THREE.Vector3(0, 0, 0)); rayPoints.push(new THREE.Vector3(0, 0, -1));
            const rayGeometry = new THREE.BufferGeometry().setFromPoints(rayPoints);
            debugRayLine = new THREE.Line(rayGeometry, rayMaterial);
            camera.add(debugRayLine); debugRayLine.visible = false;

            // Global event listeners
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', handleGameKeydown);
            document.addEventListener('keyup', handleGameKeyup);
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);
            document.addEventListener('contextmenu', (event) => event.preventDefault()); // Prevent right-click context menu

            // Pointer Lock API event listeners
            gameContainer.addEventListener('click', () => {
                // Request pointer lock only if not in game mode (i.e., from menu)
                if (currentUIMode === 'mainMenu' || currentUIMode === 'pauseMenu') {
                    requestGamePointerLock(true);
                }
            });

            document.addEventListener('pointerlockchange', () => {
                if (document.pointerLockElement === gameContainer) {
                    // Pointer lock was successful, enter game mode
                    gameActive = true; currentUIMode = 'game'; isPointerLockRequested = false;
                    mainMenuDiv.style.display = 'none'; settingsSection.style.display = 'none';
                    pauseMenu.style.display = 'none'; quitConfirmModal.style.display = 'none';
                    gameOverScreen.style.display = 'none'; gameContainer.style.display = 'block';
                    infoBox.style.display = 'none'; ammoDisplay.style.display = 'block';
                    healthDisplay.style.display = 'block'; waveInfo.style.display = 'block';
                } else {
                    // Pointer lock was exited (e.g., by user pressing Esc, or automatically)
                    gameActive = false; isPointerLockRequested = false;
                    gameContainer.style.display = 'none'; infoBox.style.display = 'block'; // Show info box when pointer lock is lost

                    // Determine which menu to show based on previous UI mode
                    if (currentUIMode === 'game') { showPauseMenu(); } // If in game, go to pause menu
                    else if (currentUIMode === 'pauseMenu') { showPauseMenu(); } // If already in pause, stay there
                    else if (currentUIMode === 'settings') { // If in settings, go back to previous menu (pause or main)
                        if (previousUIMode === 'pauseMenu') { showPauseMenu(); }
                        else { showMenuScreen(); }
                    } else if (currentUIMode === 'quitConfirm') { showPauseMenu(); } // If in quit confirm, go back to pause
                    else { showMenuScreen(); } // Default to main menu
                }
            });

            document.addEventListener('pointerlockerror', (event) => {
                // Handle cases where pointer lock fails (e.g., browser restrictions)
                if (document.pointerLockElement !== gameContainer) {
                    showMessage('Verrouillage de la souris interrompu ou n\'a pas pu être activé. Retour au menu principal.', 3000);
                    showMenuScreen();
                }
            });

            // Main menu button actions
            startGameButton.addEventListener('click', () => {
                resetGame(); // Reset game state and start first wave
                mainMenuDiv.style.display = 'none';
                gameContainer.style.display = 'block';
                requestGamePointerLock(true); // Request pointer lock to start playing
                updateAmmoDisplay(); updateHealthDisplay(); updateWaveInfoDisplay();
            });

            mainMenuSettingsButton.addEventListener('click', () => { showSettingsScreen(); });
            backToMainMenuButton.addEventListener('click', () => { showMenuScreen(); });

            // Start the animation loop
            animate();
            // Show the main menu initially
            showMenuScreen();
        }

        // Initialize the game when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => { init(); });
    </script>
</body>
</html>
